/* automatically generated by rust-bindgen 0.60.1 */

pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _ISOC95_SOURCE: u32 = 1;
pub const _ISOC99_SOURCE: u32 = 1;
pub const _ISOC11_SOURCE: u32 = 1;
pub const _ISOC2X_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _XOPEN_SOURCE: u32 = 700;
pub const _XOPEN_SOURCE_EXTENDED: u32 = 1;
pub const _LARGEFILE64_SOURCE: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_ISOCXX11: u32 = 1;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const __USE_XOPEN: u32 = 1;
pub const __USE_XOPEN_EXTENDED: u32 = 1;
pub const __USE_UNIX98: u32 = 1;
pub const _LARGEFILE_SOURCE: u32 = 1;
pub const __USE_XOPEN2K8XSI: u32 = 1;
pub const __USE_XOPEN2KXSI: u32 = 1;
pub const __USE_LARGEFILE: u32 = 1;
pub const __USE_LARGEFILE64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_GNU: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 0;
pub const __GLIBC_USE_LIB_EXT2: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 1;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 1;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const __cookie_io_functions_t_defined: u32 = 1;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_DATA: u32 = 3;
pub const SEEK_HOLE: u32 = 4;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const L_cuserid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const RENAME_NOREPLACE: u32 = 1;
pub const RENAME_EXCHANGE: u32 = 2;
pub const RENAME_WHITEOUT: u32 = 4;
pub const _GLIBCXX_CXX_CONFIG_H: u32 = 1;
pub const _GLIBCXX_RELEASE: u32 = 10;
pub const __GLIBCXX__: u32 = 20210408;
pub const _GLIBCXX_HAVE_ATTRIBUTE_VISIBILITY: u32 = 1;
pub const _GLIBCXX_USE_DEPRECATED: u32 = 1;
pub const _GLIBCXX_EXTERN_TEMPLATE: u32 = 1;
pub const _GLIBCXX_USE_DUAL_ABI: u32 = 1;
pub const _GLIBCXX_USE_CXX11_ABI: u32 = 1;
pub const _GLIBCXX_INLINE_VERSION: u32 = 0;
pub const _GLIBCXX_USE_ALLOCATOR_NEW: u32 = 1;
pub const _GLIBCXX_OS_DEFINES: u32 = 1;
pub const __NO_CTYPE: u32 = 1;
pub const _GLIBCXX_CPU_DEFINES: u32 = 1;
pub const _GLIBCXX_FAST_MATH: u32 = 0;
pub const _GLIBCXX_USE_FLOAT128: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_HAS_UNIQ_OBJ_REP: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_IS_AGGREGATE: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_LAUNDER: u32 = 1;
pub const _GLIBCXX_HAVE_BUILTIN_IS_CONSTANT_EVALUATED: u32 = 1;
pub const _GLIBCXX_HAVE_ACOSF: u32 = 1;
pub const _GLIBCXX_HAVE_ACOSL: u32 = 1;
pub const _GLIBCXX_HAVE_ALIGNED_ALLOC: u32 = 1;
pub const _GLIBCXX_HAVE_ARPA_INET_H: u32 = 1;
pub const _GLIBCXX_HAVE_ASINF: u32 = 1;
pub const _GLIBCXX_HAVE_ASINL: u32 = 1;
pub const _GLIBCXX_HAVE_AS_SYMVER_DIRECTIVE: u32 = 1;
pub const _GLIBCXX_HAVE_ATAN2F: u32 = 1;
pub const _GLIBCXX_HAVE_ATAN2L: u32 = 1;
pub const _GLIBCXX_HAVE_ATANF: u32 = 1;
pub const _GLIBCXX_HAVE_ATANL: u32 = 1;
pub const _GLIBCXX_HAVE_ATOMIC_LOCK_POLICY: u32 = 1;
pub const _GLIBCXX_HAVE_AT_QUICK_EXIT: u32 = 1;
pub const _GLIBCXX_HAVE_CEILF: u32 = 1;
pub const _GLIBCXX_HAVE_CEILL: u32 = 1;
pub const _GLIBCXX_HAVE_COMPLEX_H: u32 = 1;
pub const _GLIBCXX_HAVE_COSF: u32 = 1;
pub const _GLIBCXX_HAVE_COSHF: u32 = 1;
pub const _GLIBCXX_HAVE_COSHL: u32 = 1;
pub const _GLIBCXX_HAVE_COSL: u32 = 1;
pub const _GLIBCXX_HAVE_DIRENT_H: u32 = 1;
pub const _GLIBCXX_HAVE_DLFCN_H: u32 = 1;
pub const _GLIBCXX_HAVE_ENDIAN_H: u32 = 1;
pub const _GLIBCXX_HAVE_EXCEPTION_PTR_SINCE_GCC46: u32 = 1;
pub const _GLIBCXX_HAVE_EXECINFO_H: u32 = 1;
pub const _GLIBCXX_HAVE_EXPF: u32 = 1;
pub const _GLIBCXX_HAVE_EXPL: u32 = 1;
pub const _GLIBCXX_HAVE_FABSF: u32 = 1;
pub const _GLIBCXX_HAVE_FABSL: u32 = 1;
pub const _GLIBCXX_HAVE_FCNTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_FENV_H: u32 = 1;
pub const _GLIBCXX_HAVE_FINITE: u32 = 1;
pub const _GLIBCXX_HAVE_FINITEF: u32 = 1;
pub const _GLIBCXX_HAVE_FINITEL: u32 = 1;
pub const _GLIBCXX_HAVE_FLOAT_H: u32 = 1;
pub const _GLIBCXX_HAVE_FLOORF: u32 = 1;
pub const _GLIBCXX_HAVE_FLOORL: u32 = 1;
pub const _GLIBCXX_HAVE_FMODF: u32 = 1;
pub const _GLIBCXX_HAVE_FMODL: u32 = 1;
pub const _GLIBCXX_HAVE_FREXPF: u32 = 1;
pub const _GLIBCXX_HAVE_FREXPL: u32 = 1;
pub const _GLIBCXX_HAVE_GETIPINFO: u32 = 1;
pub const _GLIBCXX_HAVE_GETS: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOT: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOTF: u32 = 1;
pub const _GLIBCXX_HAVE_HYPOTL: u32 = 1;
pub const _GLIBCXX_HAVE_ICONV: u32 = 1;
pub const _GLIBCXX_HAVE_INT64_T: u32 = 1;
pub const _GLIBCXX_HAVE_INT64_T_LONG: u32 = 1;
pub const _GLIBCXX_HAVE_INTTYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_ISINFF: u32 = 1;
pub const _GLIBCXX_HAVE_ISINFL: u32 = 1;
pub const _GLIBCXX_HAVE_ISNANF: u32 = 1;
pub const _GLIBCXX_HAVE_ISNANL: u32 = 1;
pub const _GLIBCXX_HAVE_ISWBLANK: u32 = 1;
pub const _GLIBCXX_HAVE_LC_MESSAGES: u32 = 1;
pub const _GLIBCXX_HAVE_LDEXPF: u32 = 1;
pub const _GLIBCXX_HAVE_LDEXPL: u32 = 1;
pub const _GLIBCXX_HAVE_LIBINTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_AS: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_DATA: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_FSIZE: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_RSS: u32 = 1;
pub const _GLIBCXX_HAVE_LIMIT_VMEM: u32 = 0;
pub const _GLIBCXX_HAVE_LINK: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_FUTEX: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_RANDOM_H: u32 = 1;
pub const _GLIBCXX_HAVE_LINUX_TYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_LOCALE_H: u32 = 1;
pub const _GLIBCXX_HAVE_LOG10F: u32 = 1;
pub const _GLIBCXX_HAVE_LOG10L: u32 = 1;
pub const _GLIBCXX_HAVE_LOGF: u32 = 1;
pub const _GLIBCXX_HAVE_LOGL: u32 = 1;
pub const _GLIBCXX_HAVE_MBSTATE_T: u32 = 1;
pub const _GLIBCXX_HAVE_MEMALIGN: u32 = 1;
pub const _GLIBCXX_HAVE_MEMORY_H: u32 = 1;
pub const _GLIBCXX_HAVE_MODF: u32 = 1;
pub const _GLIBCXX_HAVE_MODFF: u32 = 1;
pub const _GLIBCXX_HAVE_MODFL: u32 = 1;
pub const _GLIBCXX_HAVE_NETDB_H: u32 = 1;
pub const _GLIBCXX_HAVE_NETINET_IN_H: u32 = 1;
pub const _GLIBCXX_HAVE_NETINET_TCP_H: u32 = 1;
pub const _GLIBCXX_HAVE_POLL: u32 = 1;
pub const _GLIBCXX_HAVE_POLL_H: u32 = 1;
pub const _GLIBCXX_HAVE_POSIX_MEMALIGN: u32 = 1;
pub const _GLIBCXX_HAVE_POWF: u32 = 1;
pub const _GLIBCXX_HAVE_POWL: u32 = 1;
pub const _GLIBCXX_HAVE_QUICK_EXIT: u32 = 1;
pub const _GLIBCXX_HAVE_READLINK: u32 = 1;
pub const _GLIBCXX_HAVE_SETENV: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOS: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOSF: u32 = 1;
pub const _GLIBCXX_HAVE_SINCOSL: u32 = 1;
pub const _GLIBCXX_HAVE_SINF: u32 = 1;
pub const _GLIBCXX_HAVE_SINHF: u32 = 1;
pub const _GLIBCXX_HAVE_SINHL: u32 = 1;
pub const _GLIBCXX_HAVE_SINL: u32 = 1;
pub const _GLIBCXX_HAVE_SOCKATMARK: u32 = 1;
pub const _GLIBCXX_HAVE_SQRTF: u32 = 1;
pub const _GLIBCXX_HAVE_SQRTL: u32 = 1;
pub const _GLIBCXX_HAVE_STDALIGN_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDBOOL_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDINT_H: u32 = 1;
pub const _GLIBCXX_HAVE_STDLIB_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRERROR_L: u32 = 1;
pub const _GLIBCXX_HAVE_STRERROR_R: u32 = 1;
pub const _GLIBCXX_HAVE_STRINGS_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRING_H: u32 = 1;
pub const _GLIBCXX_HAVE_STRTOF: u32 = 1;
pub const _GLIBCXX_HAVE_STRTOLD: u32 = 1;
pub const _GLIBCXX_HAVE_STRUCT_DIRENT_D_TYPE: u32 = 1;
pub const _GLIBCXX_HAVE_STRXFRM_L: u32 = 1;
pub const _GLIBCXX_HAVE_SYMLINK: u32 = 1;
pub const _GLIBCXX_HAVE_SYMVER_SYMBOL_RENAMING_RUNTIME_SUPPORT: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_IOCTL_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_IPC_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_PARAM_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_RESOURCE_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SDT_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SEM_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SOCKET_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_STATVFS_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_STAT_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_SYSINFO_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_TIME_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_TYPES_H: u32 = 1;
pub const _GLIBCXX_HAVE_SYS_UIO_H: u32 = 1;
pub const _GLIBCXX_HAVE_S_ISREG: u32 = 1;
pub const _GLIBCXX_HAVE_TANF: u32 = 1;
pub const _GLIBCXX_HAVE_TANHF: u32 = 1;
pub const _GLIBCXX_HAVE_TANHL: u32 = 1;
pub const _GLIBCXX_HAVE_TANL: u32 = 1;
pub const _GLIBCXX_HAVE_TGMATH_H: u32 = 1;
pub const _GLIBCXX_HAVE_TIMESPEC_GET: u32 = 1;
pub const _GLIBCXX_HAVE_TLS: u32 = 1;
pub const _GLIBCXX_HAVE_TRUNCATE: u32 = 1;
pub const _GLIBCXX_HAVE_UCHAR_H: u32 = 1;
pub const _GLIBCXX_HAVE_UNISTD_H: u32 = 1;
pub const _GLIBCXX_HAVE_UTIME_H: u32 = 1;
pub const _GLIBCXX_HAVE_VFWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_VSWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_VWSCANF: u32 = 1;
pub const _GLIBCXX_HAVE_WCHAR_H: u32 = 1;
pub const _GLIBCXX_HAVE_WCSTOF: u32 = 1;
pub const _GLIBCXX_HAVE_WCTYPE_H: u32 = 1;
pub const _GLIBCXX_HAVE_WRITEV: u32 = 1;
pub const _GLIBCXX_HAVE___CXA_THREAD_ATEXIT_IMPL: u32 = 1;
pub const LT_OBJDIR: &[u8; 7usize] = b".libs/\0";
pub const _GLIBCXX_PACKAGE_BUGREPORT: &[u8; 1usize] = b"\0";
pub const _GLIBCXX_PACKAGE_NAME: &[u8; 15usize] = b"package-unused\0";
pub const _GLIBCXX_PACKAGE_STRING: &[u8; 30usize] = b"package-unused version-unused\0";
pub const _GLIBCXX_PACKAGE_TARNAME: &[u8; 10usize] = b"libstdc++\0";
pub const _GLIBCXX_PACKAGE_URL: &[u8; 1usize] = b"\0";
pub const _GLIBCXX_PACKAGE__GLIBCXX_VERSION: &[u8; 15usize] = b"version-unused\0";
pub const STDC_HEADERS: u32 = 1;
pub const _GLIBCXX_DARWIN_USE_64_BIT_INODE: u32 = 1;
pub const _GLIBCXX11_USE_C99_COMPLEX: u32 = 1;
pub const _GLIBCXX11_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX11_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX11_USE_C99_WCHAR: u32 = 1;
pub const _GLIBCXX98_USE_C99_COMPLEX: u32 = 1;
pub const _GLIBCXX98_USE_C99_MATH: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDIO: u32 = 1;
pub const _GLIBCXX98_USE_C99_STDLIB: u32 = 1;
pub const _GLIBCXX98_USE_C99_WCHAR: u32 = 1;
pub const _GLIBCXX_ATOMIC_BUILTINS: u32 = 1;
pub const _GLIBCXX_FULLY_DYNAMIC_STRING: u32 = 0;
pub const _GLIBCXX_HAS_GTHREADS: u32 = 1;
pub const _GLIBCXX_HOSTED: u32 = 1;
pub const _GLIBCXX_RES_LIMITS: u32 = 1;
pub const _GLIBCXX_STDIO_EOF: i32 = -1;
pub const _GLIBCXX_STDIO_SEEK_CUR: u32 = 1;
pub const _GLIBCXX_STDIO_SEEK_END: u32 = 2;
pub const _GLIBCXX_SYMVER: u32 = 1;
pub const _GLIBCXX_SYMVER_GNU: u32 = 1;
pub const _GLIBCXX_USE_C11_UCHAR_CXX11: u32 = 1;
pub const _GLIBCXX_USE_C99: u32 = 1;
pub const _GLIBCXX_USE_C99_COMPLEX_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_CTYPE_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_FENV_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_INTTYPES_WCHAR_T_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_MATH_TR1: u32 = 1;
pub const _GLIBCXX_USE_C99_STDINT_TR1: u32 = 1;
pub const _GLIBCXX_USE_CLOCK_MONOTONIC: u32 = 1;
pub const _GLIBCXX_USE_CLOCK_REALTIME: u32 = 1;
pub const _GLIBCXX_USE_DECIMAL_FLOAT: u32 = 1;
pub const _GLIBCXX_USE_DEV_RANDOM: u32 = 1;
pub const _GLIBCXX_USE_FCHMOD: u32 = 1;
pub const _GLIBCXX_USE_FCHMODAT: u32 = 1;
pub const _GLIBCXX_USE_GETTIMEOFDAY: u32 = 1;
pub const _GLIBCXX_USE_GET_NPROCS: u32 = 1;
pub const _GLIBCXX_USE_INT128: u32 = 1;
pub const _GLIBCXX_USE_LFS: u32 = 1;
pub const _GLIBCXX_USE_LONG_LONG: u32 = 1;
pub const _GLIBCXX_USE_LSTAT: u32 = 1;
pub const _GLIBCXX_USE_NANOSLEEP: u32 = 1;
pub const _GLIBCXX_USE_NLS: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_COND_CLOCKWAIT: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_MUTEX_CLOCKLOCK: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_RWLOCK_CLOCKLOCK: u32 = 1;
pub const _GLIBCXX_USE_PTHREAD_RWLOCK_T: u32 = 1;
pub const _GLIBCXX_USE_RANDOM_TR1: u32 = 1;
pub const _GLIBCXX_USE_REALPATH: u32 = 1;
pub const _GLIBCXX_USE_SCHED_YIELD: u32 = 1;
pub const _GLIBCXX_USE_SC_NPROCESSORS_ONLN: u32 = 1;
pub const _GLIBCXX_USE_SENDFILE: u32 = 1;
pub const _GLIBCXX_USE_ST_MTIM: u32 = 1;
pub const _GLIBCXX_USE_TMPNAM: u32 = 1;
pub const _GLIBCXX_USE_UTIME: u32 = 1;
pub const _GLIBCXX_USE_UTIMENSAT: u32 = 1;
pub const _GLIBCXX_USE_WCHAR_T: u32 = 1;
pub const _GLIBCXX_VERBOSE: u32 = 1;
pub const _GLIBCXX_X86_RDRAND: u32 = 1;
pub const _GLIBCXX_X86_RDSEED: u32 = 1;
pub const _GTHREAD_USE_MUTEX_TIMEDLOCK: u32 = 1;
pub const _GLIBCXX_CSTDIO: u32 = 1;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__fsid_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__fsid_t),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    fn test_field___wch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t__bindgen_ty_1),
                "::",
                stringify!(__wch)
            )
        );
    }
    test_field___wch();
    fn test_field___wchb() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t__bindgen_ty_1),
                "::",
                stringify!(__wchb)
            )
        );
    }
    test_field___wchb();
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    fn test_field___count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__count)
            )
        );
    }
    test_field___count();
    fn test_field___value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__mbstate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__value)
            )
        );
    }
    test_field___value();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    fn test_field___pos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_G_fpos_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_G_fpos_t),
                "::",
                stringify!(__pos)
            )
        );
    }
    test_field___pos();
    fn test_field___state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_G_fpos_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_G_fpos_t),
                "::",
                stringify!(__state)
            )
        );
    }
    test_field___state();
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    fn test_field___pos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_G_fpos64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_G_fpos64_t),
                "::",
                stringify!(__pos)
            )
        );
    }
    test_field___pos();
    fn test_field___state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_G_fpos64_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_G_fpos64_t),
                "::",
                stringify!(__state)
            )
        );
    }
    test_field___state();
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    fn test_field__flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_flags)
            )
        );
    }
    test_field__flags();
    fn test_field__IO_read_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_ptr)
            )
        );
    }
    test_field__IO_read_ptr();
    fn test_field__IO_read_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_end)
            )
        );
    }
    test_field__IO_read_end();
    fn test_field__IO_read_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_read_base)
            )
        );
    }
    test_field__IO_read_base();
    fn test_field__IO_write_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_base)
            )
        );
    }
    test_field__IO_write_base();
    fn test_field__IO_write_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_ptr)
            )
        );
    }
    test_field__IO_write_ptr();
    fn test_field__IO_write_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_write_end)
            )
        );
    }
    test_field__IO_write_end();
    fn test_field__IO_buf_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_buf_base)
            )
        );
    }
    test_field__IO_buf_base();
    fn test_field__IO_buf_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_buf_end)
            )
        );
    }
    test_field__IO_buf_end();
    fn test_field__IO_save_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_save_base)
            )
        );
    }
    test_field__IO_save_base();
    fn test_field__IO_backup_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_backup_base)
            )
        );
    }
    test_field__IO_backup_base();
    fn test_field__IO_save_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_IO_save_end)
            )
        );
    }
    test_field__IO_save_end();
    fn test_field__markers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_markers)
            )
        );
    }
    test_field__markers();
    fn test_field__chain() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_chain)
            )
        );
    }
    test_field__chain();
    fn test_field__fileno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_fileno)
            )
        );
    }
    test_field__fileno();
    fn test_field__flags2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize
            },
            116usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_flags2)
            )
        );
    }
    test_field__flags2();
    fn test_field__old_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_old_offset)
            )
        );
    }
    test_field__old_offset();
    fn test_field__cur_column() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_cur_column)
            )
        );
    }
    test_field__cur_column();
    fn test_field__vtable_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize
            },
            130usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_vtable_offset)
            )
        );
    }
    test_field__vtable_offset();
    fn test_field__shortbuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize
            },
            131usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_shortbuf)
            )
        );
    }
    test_field__shortbuf();
    fn test_field__lock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_lock)
            )
        );
    }
    test_field__lock();
    fn test_field__offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_offset)
            )
        );
    }
    test_field__offset();
    fn test_field__codecvt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_codecvt)
            )
        );
    }
    test_field__codecvt();
    fn test_field__wide_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_wide_data)
            )
        );
    }
    test_field__wide_data();
    fn test_field__freeres_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_freeres_list)
            )
        );
    }
    test_field__freeres_list();
    fn test_field__freeres_buf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_freeres_buf)
            )
        );
    }
    test_field__freeres_buf();
    fn test_field___pad5() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(__pad5)
            )
        );
    }
    test_field___pad5();
    fn test_field__mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_mode)
            )
        );
    }
    test_field__mode();
    fn test_field__unused2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_FILE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize
            },
            196usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_FILE),
                "::",
                stringify!(_unused2)
            )
        );
    }
    test_field__unused2();
}
pub type cookie_read_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_write_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type cookie_seek_function_t = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type cookie_close_function_t = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t {
    pub read: cookie_read_function_t,
    pub write: cookie_write_function_t,
    pub seek: cookie_seek_function_t,
    pub close: cookie_close_function_t,
}
#[test]
fn bindgen_test_layout__IO_cookie_io_functions_t() {
    assert_eq!(
        ::std::mem::size_of::<_IO_cookie_io_functions_t>(),
        32usize,
        concat!("Size of: ", stringify!(_IO_cookie_io_functions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_cookie_io_functions_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_cookie_io_functions_t))
    );
    fn test_field_read() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_cookie_io_functions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_cookie_io_functions_t),
                "::",
                stringify!(read)
            )
        );
    }
    test_field_read();
    fn test_field_write() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_cookie_io_functions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_cookie_io_functions_t),
                "::",
                stringify!(write)
            )
        );
    }
    test_field_write();
    fn test_field_seek() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_cookie_io_functions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_cookie_io_functions_t),
                "::",
                stringify!(seek)
            )
        );
    }
    test_field_seek();
    fn test_field_close() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_cookie_io_functions_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).close) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_IO_cookie_io_functions_t),
                "::",
                stringify!(close)
            )
        );
    }
    test_field_close();
}
pub type cookie_io_functions_t = _IO_cookie_io_functions_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type fpos_t = __fpos_t;
pub type fpos64_t = __fpos64_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat2(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpfile64() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcloseall() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fopen64(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen64(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fopencookie(
        __magic_cookie: *mut ::std::os::raw::c_void,
        __modes: *const ::std::os::raw::c_char,
        __io_funcs: cookie_io_functions_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __f: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asprintf(
        __ptr: *mut *mut ::std::os::raw::c_char,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fgets_unlocked(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __s: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fputs_unlocked(
        __s: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fseeko64(
        __stream: *mut FILE,
        __off: __off64_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello64(__stream: *mut FILE) -> __off64_t;
}
extern "C" {
    pub fn fgetpos64(__stream: *mut FILE, __pos: *mut fpos64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos64(__stream: *mut FILE, __pos: *const fpos64_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut _sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut _sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cuserid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct obstack {
    _unused: [u8; 0],
}
extern "C" {
    pub fn obstack_printf(
        __obstack: *mut obstack,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn obstack_vprintf(
        __obstack: *mut obstack,
        __format: *const ::std::os::raw::c_char,
        __args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JPCommonLabelPhoneme {
    pub phoneme: *mut ::std::os::raw::c_char,
    pub prev: *mut _JPCommonLabelPhoneme,
    pub next: *mut _JPCommonLabelPhoneme,
    pub up: *mut _JPCommonLabelMora,
}
#[test]
fn bindgen_test_layout__JPCommonLabelPhoneme() {
    assert_eq!(
        ::std::mem::size_of::<_JPCommonLabelPhoneme>(),
        32usize,
        concat!("Size of: ", stringify!(_JPCommonLabelPhoneme))
    );
    assert_eq!(
        ::std::mem::align_of::<_JPCommonLabelPhoneme>(),
        8usize,
        concat!("Alignment of ", stringify!(_JPCommonLabelPhoneme))
    );
    fn test_field_phoneme() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelPhoneme>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).phoneme) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelPhoneme),
                "::",
                stringify!(phoneme)
            )
        );
    }
    test_field_phoneme();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelPhoneme>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelPhoneme),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelPhoneme>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelPhoneme),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_up() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelPhoneme>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).up) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelPhoneme),
                "::",
                stringify!(up)
            )
        );
    }
    test_field_up();
}
pub type JPCommonLabelPhoneme = _JPCommonLabelPhoneme;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JPCommonLabelMora {
    pub mora: *mut ::std::os::raw::c_char,
    pub head: *mut _JPCommonLabelPhoneme,
    pub tail: *mut _JPCommonLabelPhoneme,
    pub prev: *mut _JPCommonLabelMora,
    pub next: *mut _JPCommonLabelMora,
    pub up: *mut _JPCommonLabelWord,
}
#[test]
fn bindgen_test_layout__JPCommonLabelMora() {
    assert_eq!(
        ::std::mem::size_of::<_JPCommonLabelMora>(),
        48usize,
        concat!("Size of: ", stringify!(_JPCommonLabelMora))
    );
    assert_eq!(
        ::std::mem::align_of::<_JPCommonLabelMora>(),
        8usize,
        concat!("Alignment of ", stringify!(_JPCommonLabelMora))
    );
    fn test_field_mora() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelMora>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mora) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelMora),
                "::",
                stringify!(mora)
            )
        );
    }
    test_field_mora();
    fn test_field_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelMora>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelMora),
                "::",
                stringify!(head)
            )
        );
    }
    test_field_head();
    fn test_field_tail() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelMora>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tail) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelMora),
                "::",
                stringify!(tail)
            )
        );
    }
    test_field_tail();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelMora>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelMora),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelMora>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelMora),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_up() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelMora>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).up) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelMora),
                "::",
                stringify!(up)
            )
        );
    }
    test_field_up();
}
pub type JPCommonLabelMora = _JPCommonLabelMora;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JPCommonLabelWord {
    pub pron: *mut ::std::os::raw::c_char,
    pub pos: *mut ::std::os::raw::c_char,
    pub ctype: *mut ::std::os::raw::c_char,
    pub cform: *mut ::std::os::raw::c_char,
    pub head: *mut _JPCommonLabelMora,
    pub tail: *mut _JPCommonLabelMora,
    pub prev: *mut _JPCommonLabelWord,
    pub next: *mut _JPCommonLabelWord,
    pub up: *mut _JPCommonLabelAccentPhrase,
}
#[test]
fn bindgen_test_layout__JPCommonLabelWord() {
    assert_eq!(
        ::std::mem::size_of::<_JPCommonLabelWord>(),
        72usize,
        concat!("Size of: ", stringify!(_JPCommonLabelWord))
    );
    assert_eq!(
        ::std::mem::align_of::<_JPCommonLabelWord>(),
        8usize,
        concat!("Alignment of ", stringify!(_JPCommonLabelWord))
    );
    fn test_field_pron() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelWord>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pron) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelWord),
                "::",
                stringify!(pron)
            )
        );
    }
    test_field_pron();
    fn test_field_pos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelWord>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelWord),
                "::",
                stringify!(pos)
            )
        );
    }
    test_field_pos();
    fn test_field_ctype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelWord>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ctype) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelWord),
                "::",
                stringify!(ctype)
            )
        );
    }
    test_field_ctype();
    fn test_field_cform() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelWord>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cform) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelWord),
                "::",
                stringify!(cform)
            )
        );
    }
    test_field_cform();
    fn test_field_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelWord>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelWord),
                "::",
                stringify!(head)
            )
        );
    }
    test_field_head();
    fn test_field_tail() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelWord>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tail) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelWord),
                "::",
                stringify!(tail)
            )
        );
    }
    test_field_tail();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelWord>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelWord),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelWord>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelWord),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_up() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelWord>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).up) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelWord),
                "::",
                stringify!(up)
            )
        );
    }
    test_field_up();
}
pub type JPCommonLabelWord = _JPCommonLabelWord;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JPCommonLabelAccentPhrase {
    pub accent: ::std::os::raw::c_int,
    pub emotion: *mut ::std::os::raw::c_char,
    pub head: *mut _JPCommonLabelWord,
    pub tail: *mut _JPCommonLabelWord,
    pub prev: *mut _JPCommonLabelAccentPhrase,
    pub next: *mut _JPCommonLabelAccentPhrase,
    pub up: *mut _JPCommonLabelBreathGroup,
}
#[test]
fn bindgen_test_layout__JPCommonLabelAccentPhrase() {
    assert_eq!(
        ::std::mem::size_of::<_JPCommonLabelAccentPhrase>(),
        56usize,
        concat!("Size of: ", stringify!(_JPCommonLabelAccentPhrase))
    );
    assert_eq!(
        ::std::mem::align_of::<_JPCommonLabelAccentPhrase>(),
        8usize,
        concat!("Alignment of ", stringify!(_JPCommonLabelAccentPhrase))
    );
    fn test_field_accent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelAccentPhrase>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accent) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelAccentPhrase),
                "::",
                stringify!(accent)
            )
        );
    }
    test_field_accent();
    fn test_field_emotion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelAccentPhrase>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).emotion) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelAccentPhrase),
                "::",
                stringify!(emotion)
            )
        );
    }
    test_field_emotion();
    fn test_field_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelAccentPhrase>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelAccentPhrase),
                "::",
                stringify!(head)
            )
        );
    }
    test_field_head();
    fn test_field_tail() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelAccentPhrase>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tail) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelAccentPhrase),
                "::",
                stringify!(tail)
            )
        );
    }
    test_field_tail();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelAccentPhrase>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelAccentPhrase),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelAccentPhrase>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelAccentPhrase),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_up() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelAccentPhrase>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).up) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelAccentPhrase),
                "::",
                stringify!(up)
            )
        );
    }
    test_field_up();
}
pub type JPCommonLabelAccentPhrase = _JPCommonLabelAccentPhrase;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JPCommonLabelBreathGroup {
    pub head: *mut _JPCommonLabelAccentPhrase,
    pub tail: *mut _JPCommonLabelAccentPhrase,
    pub prev: *mut _JPCommonLabelBreathGroup,
    pub next: *mut _JPCommonLabelBreathGroup,
}
#[test]
fn bindgen_test_layout__JPCommonLabelBreathGroup() {
    assert_eq!(
        ::std::mem::size_of::<_JPCommonLabelBreathGroup>(),
        32usize,
        concat!("Size of: ", stringify!(_JPCommonLabelBreathGroup))
    );
    assert_eq!(
        ::std::mem::align_of::<_JPCommonLabelBreathGroup>(),
        8usize,
        concat!("Alignment of ", stringify!(_JPCommonLabelBreathGroup))
    );
    fn test_field_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelBreathGroup>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelBreathGroup),
                "::",
                stringify!(head)
            )
        );
    }
    test_field_head();
    fn test_field_tail() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelBreathGroup>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tail) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelBreathGroup),
                "::",
                stringify!(tail)
            )
        );
    }
    test_field_tail();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelBreathGroup>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelBreathGroup),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabelBreathGroup>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabelBreathGroup),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
}
pub type JPCommonLabelBreathGroup = _JPCommonLabelBreathGroup;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JPCommonLabel {
    pub size: ::std::os::raw::c_int,
    pub feature: *mut *mut ::std::os::raw::c_char,
    pub breath_head: *mut JPCommonLabelBreathGroup,
    pub breath_tail: *mut JPCommonLabelBreathGroup,
    pub accent_head: *mut JPCommonLabelAccentPhrase,
    pub accent_tail: *mut JPCommonLabelAccentPhrase,
    pub word_head: *mut JPCommonLabelWord,
    pub word_tail: *mut JPCommonLabelWord,
    pub mora_head: *mut JPCommonLabelMora,
    pub mora_tail: *mut JPCommonLabelMora,
    pub phoneme_head: *mut JPCommonLabelPhoneme,
    pub phoneme_tail: *mut JPCommonLabelPhoneme,
    pub short_pause_flag: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__JPCommonLabel() {
    assert_eq!(
        ::std::mem::size_of::<_JPCommonLabel>(),
        104usize,
        concat!("Size of: ", stringify!(_JPCommonLabel))
    );
    assert_eq!(
        ::std::mem::align_of::<_JPCommonLabel>(),
        8usize,
        concat!("Alignment of ", stringify!(_JPCommonLabel))
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabel),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_feature() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).feature) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabel),
                "::",
                stringify!(feature)
            )
        );
    }
    test_field_feature();
    fn test_field_breath_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).breath_head) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabel),
                "::",
                stringify!(breath_head)
            )
        );
    }
    test_field_breath_head();
    fn test_field_breath_tail() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).breath_tail) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabel),
                "::",
                stringify!(breath_tail)
            )
        );
    }
    test_field_breath_tail();
    fn test_field_accent_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accent_head) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabel),
                "::",
                stringify!(accent_head)
            )
        );
    }
    test_field_accent_head();
    fn test_field_accent_tail() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accent_tail) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabel),
                "::",
                stringify!(accent_tail)
            )
        );
    }
    test_field_accent_tail();
    fn test_field_word_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).word_head) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabel),
                "::",
                stringify!(word_head)
            )
        );
    }
    test_field_word_head();
    fn test_field_word_tail() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).word_tail) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabel),
                "::",
                stringify!(word_tail)
            )
        );
    }
    test_field_word_tail();
    fn test_field_mora_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mora_head) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabel),
                "::",
                stringify!(mora_head)
            )
        );
    }
    test_field_mora_head();
    fn test_field_mora_tail() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mora_tail) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabel),
                "::",
                stringify!(mora_tail)
            )
        );
    }
    test_field_mora_tail();
    fn test_field_phoneme_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).phoneme_head) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabel),
                "::",
                stringify!(phoneme_head)
            )
        );
    }
    test_field_phoneme_head();
    fn test_field_phoneme_tail() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).phoneme_tail) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabel),
                "::",
                stringify!(phoneme_tail)
            )
        );
    }
    test_field_phoneme_tail();
    fn test_field_short_pause_flag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonLabel>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).short_pause_flag) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonLabel),
                "::",
                stringify!(short_pause_flag)
            )
        );
    }
    test_field_short_pause_flag();
}
pub type JPCommonLabel = _JPCommonLabel;
extern "C" {
    pub fn JPCommonLabel_initialize(label: *mut JPCommonLabel);
}
extern "C" {
    pub fn JPCommonLabel_push_word(
        label: *mut JPCommonLabel,
        pron: *const ::std::os::raw::c_char,
        pos: *const ::std::os::raw::c_char,
        ctype: *const ::std::os::raw::c_char,
        cform: *const ::std::os::raw::c_char,
        acc: ::std::os::raw::c_int,
        chain_flag: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn JPCommonLabel_make(label: *mut JPCommonLabel);
}
extern "C" {
    pub fn JPCommonLabel_get_size(label: *mut JPCommonLabel) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn JPCommonLabel_get_feature(label: *mut JPCommonLabel)
        -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn JPCommonLabel_print(label: *mut JPCommonLabel);
}
extern "C" {
    pub fn JPCommonLabel_fprint(label: *mut JPCommonLabel, fp: *mut FILE);
}
extern "C" {
    pub fn JPCommonLabel_clear(label: *mut JPCommonLabel);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JPCommonNode {
    pub pron: *mut ::std::os::raw::c_char,
    pub pos: *mut ::std::os::raw::c_char,
    pub ctype: *mut ::std::os::raw::c_char,
    pub cform: *mut ::std::os::raw::c_char,
    pub acc: ::std::os::raw::c_int,
    pub chain_flag: ::std::os::raw::c_int,
    pub prev: *mut _JPCommonNode,
    pub next: *mut _JPCommonNode,
}
#[test]
fn bindgen_test_layout__JPCommonNode() {
    assert_eq!(
        ::std::mem::size_of::<_JPCommonNode>(),
        56usize,
        concat!("Size of: ", stringify!(_JPCommonNode))
    );
    assert_eq!(
        ::std::mem::align_of::<_JPCommonNode>(),
        8usize,
        concat!("Alignment of ", stringify!(_JPCommonNode))
    );
    fn test_field_pron() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pron) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonNode),
                "::",
                stringify!(pron)
            )
        );
    }
    test_field_pron();
    fn test_field_pos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonNode),
                "::",
                stringify!(pos)
            )
        );
    }
    test_field_pos();
    fn test_field_ctype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ctype) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonNode),
                "::",
                stringify!(ctype)
            )
        );
    }
    test_field_ctype();
    fn test_field_cform() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cform) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonNode),
                "::",
                stringify!(cform)
            )
        );
    }
    test_field_cform();
    fn test_field_acc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).acc) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonNode),
                "::",
                stringify!(acc)
            )
        );
    }
    test_field_acc();
    fn test_field_chain_flag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).chain_flag) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonNode),
                "::",
                stringify!(chain_flag)
            )
        );
    }
    test_field_chain_flag();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonNode),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommonNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommonNode),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
}
pub type JPCommonNode = _JPCommonNode;
extern "C" {
    pub fn JPCommonNode_initialize(node: *mut JPCommonNode);
}
extern "C" {
    pub fn JPCommonNode_set_pron(node: *mut JPCommonNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn JPCommonNode_set_pos(node: *mut JPCommonNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn JPCommonNode_set_ctype(node: *mut JPCommonNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn JPCommonNode_set_cform(node: *mut JPCommonNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn JPCommonNode_set_acc(node: *mut JPCommonNode, acc: ::std::os::raw::c_int);
}
extern "C" {
    pub fn JPCommonNode_set_chain_flag(node: *mut JPCommonNode, flag: ::std::os::raw::c_int);
}
extern "C" {
    pub fn JPCommonNode_get_pron(node: *mut JPCommonNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn JPCommonNode_get_pos(node: *mut JPCommonNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn JPCommonNode_get_ctype(node: *mut JPCommonNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn JPCommonNode_get_cform(node: *mut JPCommonNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn JPCommonNode_get_acc(node: *mut JPCommonNode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn JPCommonNode_get_chain_flag(node: *mut JPCommonNode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn JPCommonNode_print(node: *mut JPCommonNode);
}
extern "C" {
    pub fn JPCommonNode_fprint(node: *mut JPCommonNode, fp: *mut FILE);
}
extern "C" {
    pub fn JPCommonNode_clear(node: *mut JPCommonNode);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JPCommon {
    pub head: *mut JPCommonNode,
    pub tail: *mut JPCommonNode,
    pub label: *mut JPCommonLabel,
}
#[test]
fn bindgen_test_layout__JPCommon() {
    assert_eq!(
        ::std::mem::size_of::<_JPCommon>(),
        24usize,
        concat!("Size of: ", stringify!(_JPCommon))
    );
    assert_eq!(
        ::std::mem::align_of::<_JPCommon>(),
        8usize,
        concat!("Alignment of ", stringify!(_JPCommon))
    );
    fn test_field_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommon>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommon),
                "::",
                stringify!(head)
            )
        );
    }
    test_field_head();
    fn test_field_tail() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommon>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tail) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommon),
                "::",
                stringify!(tail)
            )
        );
    }
    test_field_tail();
    fn test_field_label() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_JPCommon>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).label) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_JPCommon),
                "::",
                stringify!(label)
            )
        );
    }
    test_field_label();
}
pub type JPCommon = _JPCommon;
extern "C" {
    pub fn JPCommon_initialize(jpcommon: *mut JPCommon);
}
extern "C" {
    pub fn JPCommon_push(jpcommon: *mut JPCommon, node: *mut JPCommonNode);
}
extern "C" {
    pub fn JPCommon_make_label(jpcommon: *mut JPCommon);
}
extern "C" {
    pub fn JPCommon_get_label_size(jpcommon: *mut JPCommon) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn JPCommon_get_label_feature(jpcommon: *mut JPCommon) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn JPCommon_print(jpcommon: *mut JPCommon);
}
extern "C" {
    pub fn JPCommon_fprint(jpcommon: *mut JPCommon, fp: *mut FILE);
}
extern "C" {
    pub fn JPCommon_refresh(jpcommon: *mut JPCommon);
}
extern "C" {
    pub fn JPCommon_clear(jpcommon: *mut JPCommon);
}
#[doc = " DictionaryInfo structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mecab_dictionary_info_t {
    #[doc = " filename of dictionary"]
    #[doc = " On Windows, filename is stored in UTF-8 encoding"]
    pub filename: *const ::std::os::raw::c_char,
    #[doc = " character set of the dictionary. e.g., \"SHIFT-JIS\", \"UTF-8\""]
    pub charset: *const ::std::os::raw::c_char,
    #[doc = " How many words are registered in this dictionary."]
    pub size: ::std::os::raw::c_uint,
    #[doc = " dictionary type"]
    #[doc = " this value should be MECAB_USR_DIC, MECAB_SYS_DIC, or MECAB_UNK_DIC."]
    pub type_: ::std::os::raw::c_int,
    #[doc = " left attributes size"]
    pub lsize: ::std::os::raw::c_uint,
    #[doc = " right attributes size"]
    pub rsize: ::std::os::raw::c_uint,
    #[doc = " version of this dictionary"]
    pub version: ::std::os::raw::c_ushort,
    #[doc = " pointer to the next dictionary info."]
    pub next: *mut mecab_dictionary_info_t,
}
#[test]
fn bindgen_test_layout_mecab_dictionary_info_t() {
    assert_eq!(
        ::std::mem::size_of::<mecab_dictionary_info_t>(),
        48usize,
        concat!("Size of: ", stringify!(mecab_dictionary_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mecab_dictionary_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mecab_dictionary_info_t))
    );
    fn test_field_filename() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_dictionary_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_dictionary_info_t),
                "::",
                stringify!(filename)
            )
        );
    }
    test_field_filename();
    fn test_field_charset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_dictionary_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).charset) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_dictionary_info_t),
                "::",
                stringify!(charset)
            )
        );
    }
    test_field_charset();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_dictionary_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_dictionary_info_t),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_dictionary_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_dictionary_info_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_lsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_dictionary_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lsize) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_dictionary_info_t),
                "::",
                stringify!(lsize)
            )
        );
    }
    test_field_lsize();
    fn test_field_rsize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_dictionary_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rsize) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_dictionary_info_t),
                "::",
                stringify!(rsize)
            )
        );
    }
    test_field_rsize();
    fn test_field_version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_dictionary_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_dictionary_info_t),
                "::",
                stringify!(version)
            )
        );
    }
    test_field_version();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_dictionary_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_dictionary_info_t),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
}
#[doc = " Path structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mecab_path_t {
    #[doc = " pointer to the right node"]
    pub rnode: *mut mecab_node_t,
    #[doc = " pointer to the next right path"]
    pub rnext: *mut mecab_path_t,
    #[doc = " pointer to the left node"]
    pub lnode: *mut mecab_node_t,
    #[doc = " pointer to the next left path"]
    pub lnext: *mut mecab_path_t,
    #[doc = " local cost"]
    pub cost: ::std::os::raw::c_int,
    #[doc = " marginal probability"]
    pub prob: f32,
}
#[test]
fn bindgen_test_layout_mecab_path_t() {
    assert_eq!(
        ::std::mem::size_of::<mecab_path_t>(),
        40usize,
        concat!("Size of: ", stringify!(mecab_path_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mecab_path_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mecab_path_t))
    );
    fn test_field_rnode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_path_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rnode) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_path_t),
                "::",
                stringify!(rnode)
            )
        );
    }
    test_field_rnode();
    fn test_field_rnext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_path_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rnext) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_path_t),
                "::",
                stringify!(rnext)
            )
        );
    }
    test_field_rnext();
    fn test_field_lnode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_path_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lnode) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_path_t),
                "::",
                stringify!(lnode)
            )
        );
    }
    test_field_lnode();
    fn test_field_lnext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_path_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lnext) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_path_t),
                "::",
                stringify!(lnext)
            )
        );
    }
    test_field_lnext();
    fn test_field_cost() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_path_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cost) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_path_t),
                "::",
                stringify!(cost)
            )
        );
    }
    test_field_cost();
    fn test_field_prob() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_path_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prob) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_path_t),
                "::",
                stringify!(prob)
            )
        );
    }
    test_field_prob();
}
#[doc = " Node structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mecab_node_t {
    #[doc = " pointer to the previous node."]
    pub prev: *mut mecab_node_t,
    #[doc = " pointer to the next node."]
    pub next: *mut mecab_node_t,
    #[doc = " pointer to the node which ends at the same position."]
    pub enext: *mut mecab_node_t,
    #[doc = " pointer to the node which starts at the same position."]
    pub bnext: *mut mecab_node_t,
    #[doc = " pointer to the right path."]
    #[doc = " this value is NULL if MECAB_ONE_BEST mode."]
    pub rpath: *mut mecab_path_t,
    #[doc = " pointer to the right path."]
    #[doc = " this value is NULL if MECAB_ONE_BEST mode."]
    pub lpath: *mut mecab_path_t,
    #[doc = " surface string."]
    #[doc = " this value is not 0 terminated."]
    #[doc = " You can get the length with length/rlength members."]
    pub surface: *const ::std::os::raw::c_char,
    #[doc = " feature string"]
    pub feature: *const ::std::os::raw::c_char,
    #[doc = " unique node id"]
    pub id: ::std::os::raw::c_uint,
    #[doc = " length of the surface form."]
    pub length: ::std::os::raw::c_ushort,
    #[doc = " length of the surface form including white space before the morph."]
    pub rlength: ::std::os::raw::c_ushort,
    #[doc = " right attribute id"]
    pub rcAttr: ::std::os::raw::c_ushort,
    #[doc = " left attribute id"]
    pub lcAttr: ::std::os::raw::c_ushort,
    #[doc = " unique part of speech id. This value is defined in \"pos.def\" file."]
    pub posid: ::std::os::raw::c_ushort,
    #[doc = " character type"]
    pub char_type: ::std::os::raw::c_uchar,
    #[doc = " status of this model."]
    #[doc = " This value is MECAB_NOR_NODE, MECAB_UNK_NODE, MECAB_BOS_NODE, MECAB_EOS_NODE, or MECAB_EON_NODE."]
    pub stat: ::std::os::raw::c_uchar,
    #[doc = " set 1 if this node is best node."]
    pub isbest: ::std::os::raw::c_uchar,
    #[doc = " forward accumulative log summation."]
    #[doc = " This value is only available when MECAB_MARGINAL_PROB is passed."]
    pub alpha: f32,
    #[doc = " backward accumulative log summation."]
    #[doc = " This value is only available when MECAB_MARGINAL_PROB is passed."]
    pub beta: f32,
    #[doc = " marginal probability."]
    #[doc = " This value is only available when MECAB_MARGINAL_PROB is passed."]
    pub prob: f32,
    #[doc = " word cost."]
    pub wcost: ::std::os::raw::c_short,
    #[doc = " best accumulative cost from bos node to this node."]
    pub cost: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_mecab_node_t() {
    assert_eq!(
        ::std::mem::size_of::<mecab_node_t>(),
        112usize,
        concat!("Size of: ", stringify!(mecab_node_t))
    );
    assert_eq!(
        ::std::mem::align_of::<mecab_node_t>(),
        8usize,
        concat!("Alignment of ", stringify!(mecab_node_t))
    );
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_node_t),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_node_t),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_enext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enext) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_node_t),
                "::",
                stringify!(enext)
            )
        );
    }
    test_field_enext();
    fn test_field_bnext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bnext) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_node_t),
                "::",
                stringify!(bnext)
            )
        );
    }
    test_field_bnext();
    fn test_field_rpath() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rpath) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_node_t),
                "::",
                stringify!(rpath)
            )
        );
    }
    test_field_rpath();
    fn test_field_lpath() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lpath) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_node_t),
                "::",
                stringify!(lpath)
            )
        );
    }
    test_field_lpath();
    fn test_field_surface() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).surface) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_node_t),
                "::",
                stringify!(surface)
            )
        );
    }
    test_field_surface();
    fn test_field_feature() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).feature) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_node_t),
                "::",
                stringify!(feature)
            )
        );
    }
    test_field_feature();
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_node_t),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_node_t),
                "::",
                stringify!(length)
            )
        );
    }
    test_field_length();
    fn test_field_rlength() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rlength) as usize - ptr as usize
            },
            70usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_node_t),
                "::",
                stringify!(rlength)
            )
        );
    }
    test_field_rlength();
    fn test_field_rcAttr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rcAttr) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_node_t),
                "::",
                stringify!(rcAttr)
            )
        );
    }
    test_field_rcAttr();
    fn test_field_lcAttr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lcAttr) as usize - ptr as usize
            },
            74usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_node_t),
                "::",
                stringify!(lcAttr)
            )
        );
    }
    test_field_lcAttr();
    fn test_field_posid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).posid) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_node_t),
                "::",
                stringify!(posid)
            )
        );
    }
    test_field_posid();
    fn test_field_char_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).char_type) as usize - ptr as usize
            },
            78usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_node_t),
                "::",
                stringify!(char_type)
            )
        );
    }
    test_field_char_type();
    fn test_field_stat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stat) as usize - ptr as usize
            },
            79usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_node_t),
                "::",
                stringify!(stat)
            )
        );
    }
    test_field_stat();
    fn test_field_isbest() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).isbest) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_node_t),
                "::",
                stringify!(isbest)
            )
        );
    }
    test_field_isbest();
    fn test_field_alpha() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alpha) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_node_t),
                "::",
                stringify!(alpha)
            )
        );
    }
    test_field_alpha();
    fn test_field_beta() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).beta) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_node_t),
                "::",
                stringify!(beta)
            )
        );
    }
    test_field_beta();
    fn test_field_prob() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prob) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_node_t),
                "::",
                stringify!(prob)
            )
        );
    }
    test_field_prob();
    fn test_field_wcost() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).wcost) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_node_t),
                "::",
                stringify!(wcost)
            )
        );
    }
    test_field_wcost();
    fn test_field_cost() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<mecab_node_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cost) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(mecab_node_t),
                "::",
                stringify!(cost)
            )
        );
    }
    test_field_cost();
}
pub const MECAB_NOR_NODE: _bindgen_ty_1 = _bindgen_ty_1::MECAB_NOR_NODE;
pub const MECAB_UNK_NODE: _bindgen_ty_1 = _bindgen_ty_1::MECAB_UNK_NODE;
pub const MECAB_BOS_NODE: _bindgen_ty_1 = _bindgen_ty_1::MECAB_BOS_NODE;
pub const MECAB_EOS_NODE: _bindgen_ty_1 = _bindgen_ty_1::MECAB_EOS_NODE;
pub const MECAB_EON_NODE: _bindgen_ty_1 = _bindgen_ty_1::MECAB_EON_NODE;
#[repr(u32)]
#[doc = " Parameters for MeCab::Node::stat"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_1 {
    #[doc = " Normal node defined in the dictionary."]
    MECAB_NOR_NODE = 0,
    #[doc = " Unknown node not defined in the dictionary."]
    MECAB_UNK_NODE = 1,
    #[doc = " Virtual node representing a beginning of the sentence."]
    MECAB_BOS_NODE = 2,
    #[doc = " Virtual node representing a end of the sentence."]
    MECAB_EOS_NODE = 3,
    #[doc = " Virtual node representing a end of the N-best enumeration."]
    MECAB_EON_NODE = 4,
}
pub const MECAB_SYS_DIC: _bindgen_ty_2 = _bindgen_ty_2::MECAB_SYS_DIC;
pub const MECAB_USR_DIC: _bindgen_ty_2 = _bindgen_ty_2::MECAB_USR_DIC;
pub const MECAB_UNK_DIC: _bindgen_ty_2 = _bindgen_ty_2::MECAB_UNK_DIC;
#[repr(u32)]
#[doc = " Parameters for MeCab::DictionaryInfo::type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_2 {
    #[doc = " This is a system dictionary."]
    MECAB_SYS_DIC = 0,
    #[doc = " This is a user dictionary."]
    MECAB_USR_DIC = 1,
    #[doc = " This is a unknown word dictionary."]
    MECAB_UNK_DIC = 2,
}
pub const MECAB_ONE_BEST: _bindgen_ty_3 = _bindgen_ty_3::MECAB_ONE_BEST;
pub const MECAB_NBEST: _bindgen_ty_3 = _bindgen_ty_3::MECAB_NBEST;
pub const MECAB_PARTIAL: _bindgen_ty_3 = _bindgen_ty_3::MECAB_PARTIAL;
pub const MECAB_MARGINAL_PROB: _bindgen_ty_3 = _bindgen_ty_3::MECAB_MARGINAL_PROB;
pub const MECAB_ALTERNATIVE: _bindgen_ty_3 = _bindgen_ty_3::MECAB_ALTERNATIVE;
pub const MECAB_ALL_MORPHS: _bindgen_ty_3 = _bindgen_ty_3::MECAB_ALL_MORPHS;
pub const MECAB_ALLOCATE_SENTENCE: _bindgen_ty_3 = _bindgen_ty_3::MECAB_ALLOCATE_SENTENCE;
#[repr(u32)]
#[doc = " Parameters for MeCab::Lattice::request_type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_3 {
    #[doc = " One best result is obtained (default mode)"]
    MECAB_ONE_BEST = 1,
    #[doc = " Set this flag if you want to obtain N best results."]
    MECAB_NBEST = 2,
    #[doc = " Set this flag if you want to enable a partial parsing mode."]
    #[doc = " When this flag is set, the input |sentence| needs to be written"]
    #[doc = " in partial parsing format."]
    MECAB_PARTIAL = 4,
    #[doc = " Set this flag if you want to obtain marginal probabilities."]
    #[doc = " Marginal probability is set in MeCab::Node::prob."]
    #[doc = " The parsing speed will get 3-5 times slower than the default mode."]
    MECAB_MARGINAL_PROB = 8,
    #[doc = " Set this flag if you want to obtain alternative results."]
    #[doc = " Not implemented."]
    MECAB_ALTERNATIVE = 16,
    #[doc = " When this flag is set, the result linked-list (Node::next/prev)"]
    #[doc = " traverses all nodes in the lattice."]
    MECAB_ALL_MORPHS = 32,
    #[doc = " When this flag is set, tagger internally copies the body of passed"]
    #[doc = " sentence into internal buffer."]
    MECAB_ALLOCATE_SENTENCE = 64,
}
pub const MECAB_ANY_BOUNDARY: _bindgen_ty_4 = _bindgen_ty_4::MECAB_ANY_BOUNDARY;
pub const MECAB_TOKEN_BOUNDARY: _bindgen_ty_4 = _bindgen_ty_4::MECAB_TOKEN_BOUNDARY;
pub const MECAB_INSIDE_TOKEN: _bindgen_ty_4 = _bindgen_ty_4::MECAB_INSIDE_TOKEN;
#[repr(u32)]
#[doc = " Parameters for MeCab::Lattice::boundary_constraint_type"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum _bindgen_ty_4 {
    #[doc = " The token boundary is not specified."]
    MECAB_ANY_BOUNDARY = 0,
    #[doc = " The position is a strong token boundary."]
    MECAB_TOKEN_BOUNDARY = 1,
    #[doc = " The position is not a token boundary."]
    MECAB_INSIDE_TOKEN = 2,
}
pub type std_nullptr_t = *const ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mecab_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mecab_model_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mecab_lattice_t {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " C wrapper of MeCab::Tagger::create(argc, argv)"]
    pub fn mecab_new(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut mecab_t;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Tagger::create(arg)"]
    pub fn mecab_new2(arg: *const ::std::os::raw::c_char) -> *mut mecab_t;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Tagger::version()"]
    pub fn mecab_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " C wrapper of MeCab::getLastError()"]
    pub fn mecab_strerror(mecab: *mut mecab_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " C wrapper of MeCab::deleteTagger(tagger)"]
    pub fn mecab_destroy(mecab: *mut mecab_t);
}
extern "C" {
    #[doc = " C wrapper of MeCab::Tagger:set_partial()"]
    pub fn mecab_get_partial(mecab: *mut mecab_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Tagger::partial()"]
    pub fn mecab_set_partial(mecab: *mut mecab_t, partial: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " C wrapper of MeCab::Tagger::theta()"]
    pub fn mecab_get_theta(mecab: *mut mecab_t) -> f32;
}
extern "C" {
    #[doc = " C wrapper of  MeCab::Tagger::set_theta()"]
    pub fn mecab_set_theta(mecab: *mut mecab_t, theta: f32);
}
extern "C" {
    #[doc = " C wrapper of MeCab::Tagger::lattice_level()"]
    pub fn mecab_get_lattice_level(mecab: *mut mecab_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Tagger::set_lattice_level()"]
    pub fn mecab_set_lattice_level(mecab: *mut mecab_t, level: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " C wrapper of MeCab::Tagger::all_morphs()"]
    pub fn mecab_get_all_morphs(mecab: *mut mecab_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Tagger::set_all_moprhs()"]
    pub fn mecab_set_all_morphs(mecab: *mut mecab_t, all_morphs: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " C wrapper of MeCab::Tagger::parse(MeCab::Lattice *lattice)"]
    pub fn mecab_parse_lattice(
        mecab: *mut mecab_t,
        lattice: *mut mecab_lattice_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Tagger::parse(const char *str)"]
    pub fn mecab_sparse_tostr(
        mecab: *mut mecab_t,
        str_: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Tagger::parse(const char *str, size_t len)"]
    pub fn mecab_sparse_tostr2(
        mecab: *mut mecab_t,
        str_: *const ::std::os::raw::c_char,
        len: usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Tagger::parse(const char *str, char *ostr, size_t olen)"]
    pub fn mecab_sparse_tostr3(
        mecab: *mut mecab_t,
        str_: *const ::std::os::raw::c_char,
        len: usize,
        ostr: *mut ::std::os::raw::c_char,
        olen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Tagger::parseToNode(const char *str)"]
    pub fn mecab_sparse_tonode(
        mecab: *mut mecab_t,
        arg1: *const ::std::os::raw::c_char,
    ) -> *const mecab_node_t;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Tagger::parseToNode(const char *str, size_t len)"]
    pub fn mecab_sparse_tonode2(
        mecab: *mut mecab_t,
        arg1: *const ::std::os::raw::c_char,
        arg2: usize,
    ) -> *const mecab_node_t;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Tagger::parseNBest(size_t N, const char *str)"]
    pub fn mecab_nbest_sparse_tostr(
        mecab: *mut mecab_t,
        N: usize,
        str_: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Tagger::parseNBest(size_t N, const char *str, size_t len)"]
    pub fn mecab_nbest_sparse_tostr2(
        mecab: *mut mecab_t,
        N: usize,
        str_: *const ::std::os::raw::c_char,
        len: usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Tagger::parseNBest(size_t N, const char *str, char *ostr, size_t olen)"]
    pub fn mecab_nbest_sparse_tostr3(
        mecab: *mut mecab_t,
        N: usize,
        str_: *const ::std::os::raw::c_char,
        len: usize,
        ostr: *mut ::std::os::raw::c_char,
        olen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Tagger::parseNBestInit(const char *str)"]
    pub fn mecab_nbest_init(
        mecab: *mut mecab_t,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Tagger::parseNBestInit(const char *str, size_t len)"]
    pub fn mecab_nbest_init2(
        mecab: *mut mecab_t,
        str_: *const ::std::os::raw::c_char,
        len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Tagger::next()"]
    pub fn mecab_nbest_next_tostr(mecab: *mut mecab_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Tagger::next(char *ostr, size_t olen)"]
    pub fn mecab_nbest_next_tostr2(
        mecab: *mut mecab_t,
        ostr: *mut ::std::os::raw::c_char,
        olen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Tagger::nextNode()"]
    pub fn mecab_nbest_next_tonode(mecab: *mut mecab_t) -> *const mecab_node_t;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Tagger::formatNode(const Node *node)"]
    pub fn mecab_format_node(
        mecab: *mut mecab_t,
        node: *const mecab_node_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Tagger::dictionary_info()"]
    pub fn mecab_dictionary_info(mecab: *mut mecab_t) -> *const mecab_dictionary_info_t;
}
extern "C" {
    #[doc = " C wrapper of MeCab::createLattice()"]
    pub fn mecab_lattice_new() -> *mut mecab_lattice_t;
}
extern "C" {
    #[doc = " C wrapper of MeCab::deleteLattice(lattice)"]
    pub fn mecab_lattice_destroy(lattice: *mut mecab_lattice_t);
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::clear()"]
    pub fn mecab_lattice_clear(lattice: *mut mecab_lattice_t);
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::is_available()"]
    pub fn mecab_lattice_is_available(lattice: *mut mecab_lattice_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::bos_node()"]
    pub fn mecab_lattice_get_bos_node(lattice: *mut mecab_lattice_t) -> *mut mecab_node_t;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::eos_node()"]
    pub fn mecab_lattice_get_eos_node(lattice: *mut mecab_lattice_t) -> *mut mecab_node_t;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::begin_nodes()"]
    pub fn mecab_lattice_get_all_begin_nodes(
        lattice: *mut mecab_lattice_t,
    ) -> *mut *mut mecab_node_t;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::end_nodes()"]
    pub fn mecab_lattice_get_all_end_nodes(lattice: *mut mecab_lattice_t)
        -> *mut *mut mecab_node_t;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::begin_nodes(pos)"]
    pub fn mecab_lattice_get_begin_nodes(
        lattice: *mut mecab_lattice_t,
        pos: usize,
    ) -> *mut mecab_node_t;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::end_nodes(pos)"]
    pub fn mecab_lattice_get_end_nodes(
        lattice: *mut mecab_lattice_t,
        pos: usize,
    ) -> *mut mecab_node_t;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::sentence()"]
    pub fn mecab_lattice_get_sentence(
        lattice: *mut mecab_lattice_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::set_sentence(sentence)"]
    pub fn mecab_lattice_set_sentence(
        lattice: *mut mecab_lattice_t,
        sentence: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::set_sentence(sentence, len)"]
    pub fn mecab_lattice_set_sentence2(
        lattice: *mut mecab_lattice_t,
        sentence: *const ::std::os::raw::c_char,
        len: usize,
    );
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::size()"]
    pub fn mecab_lattice_get_size(lattice: *mut mecab_lattice_t) -> usize;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::Z()"]
    pub fn mecab_lattice_get_z(lattice: *mut mecab_lattice_t) -> f64;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::set_Z()"]
    pub fn mecab_lattice_set_z(lattice: *mut mecab_lattice_t, Z: f64);
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::theta()"]
    pub fn mecab_lattice_get_theta(lattice: *mut mecab_lattice_t) -> f64;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::set_theta()"]
    pub fn mecab_lattice_set_theta(lattice: *mut mecab_lattice_t, theta: f64);
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::next()"]
    pub fn mecab_lattice_next(lattice: *mut mecab_lattice_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::request_type()"]
    pub fn mecab_lattice_get_request_type(lattice: *mut mecab_lattice_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::has_request_type()"]
    pub fn mecab_lattice_has_request_type(
        lattice: *mut mecab_lattice_t,
        request_type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::set_request_type()"]
    pub fn mecab_lattice_set_request_type(
        lattice: *mut mecab_lattice_t,
        request_type: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::add_request_type()"]
    pub fn mecab_lattice_add_request_type(
        lattice: *mut mecab_lattice_t,
        request_type: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::remove_request_type()"]
    pub fn mecab_lattice_remove_request_type(
        lattice: *mut mecab_lattice_t,
        request_type: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::newNode();"]
    pub fn mecab_lattice_new_node(lattice: *mut mecab_lattice_t) -> *mut mecab_node_t;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::toString()"]
    pub fn mecab_lattice_tostr(lattice: *mut mecab_lattice_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::toString(buf, size)"]
    pub fn mecab_lattice_tostr2(
        lattice: *mut mecab_lattice_t,
        buf: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::enumNBestAsString(N)"]
    pub fn mecab_lattice_nbest_tostr(
        lattice: *mut mecab_lattice_t,
        N: usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::enumNBestAsString(N, buf, size)"]
    pub fn mecab_lattice_nbest_tostr2(
        lattice: *mut mecab_lattice_t,
        N: usize,
        buf: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::has_constraint()"]
    pub fn mecab_lattice_has_constraint(lattice: *mut mecab_lattice_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::boundary_constraint(pos)"]
    pub fn mecab_lattice_get_boundary_constraint(
        lattice: *mut mecab_lattice_t,
        pos: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::feature_constraint(pos)"]
    pub fn mecab_lattice_get_feature_constraint(
        lattice: *mut mecab_lattice_t,
        pos: usize,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::boundary_constraint(pos, type)"]
    pub fn mecab_lattice_set_boundary_constraint(
        lattice: *mut mecab_lattice_t,
        pos: usize,
        boundary_type: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::set_feature_constraint(begin_pos, end_pos, feature)"]
    pub fn mecab_lattice_set_feature_constraint(
        lattice: *mut mecab_lattice_t,
        begin_pos: usize,
        end_pos: usize,
        feature: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::set_result(result);"]
    pub fn mecab_lattice_set_result(
        lattice: *mut mecab_lattice_t,
        result: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " C wrapper of MeCab::Lattice::what()"]
    pub fn mecab_lattice_strerror(lattice: *mut mecab_lattice_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " C wapper of MeCab::Model::create(argc, argv)"]
    pub fn mecab_model_new(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut mecab_model_t;
}
extern "C" {
    #[doc = " C wapper of MeCab::Model::create(arg)"]
    pub fn mecab_model_new2(arg: *const ::std::os::raw::c_char) -> *mut mecab_model_t;
}
extern "C" {
    #[doc = " C wapper of MeCab::deleteModel(model)"]
    pub fn mecab_model_destroy(model: *mut mecab_model_t);
}
extern "C" {
    #[doc = " C wapper of MeCab::Model::createTagger()"]
    pub fn mecab_model_new_tagger(model: *mut mecab_model_t) -> *mut mecab_t;
}
extern "C" {
    #[doc = " C wapper of MeCab::Model::createLattice()"]
    pub fn mecab_model_new_lattice(model: *mut mecab_model_t) -> *mut mecab_lattice_t;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Model::swap()"]
    pub fn mecab_model_swap(
        model: *mut mecab_model_t,
        new_model: *mut mecab_model_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " C wapper of MeCab::Model::dictionary_info()"]
    pub fn mecab_model_dictionary_info(model: *mut mecab_model_t)
        -> *const mecab_dictionary_info_t;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Model::transition_cost()"]
    pub fn mecab_model_transition_cost(
        model: *mut mecab_model_t,
        rcAttr: ::std::os::raw::c_ushort,
        lcAttr: ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " C wrapper of MeCab::Model::lookup()"]
    pub fn mecab_model_lookup(
        model: *mut mecab_model_t,
        begin: *const ::std::os::raw::c_char,
        end: *const ::std::os::raw::c_char,
        lattice: *mut mecab_lattice_t,
    ) -> *mut mecab_node_t;
}
extern "C" {
    pub fn mecab_do(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mecab_dict_index(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mecab_dict_gen(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mecab_cost_train(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mecab_system_eval(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mecab_test_gen(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " DictionaryInfo structure"]
pub type MeCab_DictionaryInfo = mecab_dictionary_info_t;
#[doc = " Path structure"]
pub type MeCab_Path = mecab_path_t;
#[doc = " Node structure"]
pub type MeCab_Node = mecab_node_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MeCab_Allocator {
    pub _address: u8,
}
#[repr(C)]
pub struct MeCab_Lattice__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Lattice class"]
#[repr(C)]
#[derive(Debug)]
pub struct MeCab_Lattice {
    pub vtable_: *const MeCab_Lattice__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_MeCab_Lattice() {
    assert_eq!(
        ::std::mem::size_of::<MeCab_Lattice>(),
        8usize,
        concat!("Size of: ", stringify!(MeCab_Lattice))
    );
    assert_eq!(
        ::std::mem::align_of::<MeCab_Lattice>(),
        8usize,
        concat!("Alignment of ", stringify!(MeCab_Lattice))
    );
}
extern "C" {
    #[doc = " Create new Lattice object"]
    #[doc = " @return new Lattice object"]
    #[link_name = "\u{1}_ZN5MeCab7Lattice6createEv"]
    pub fn MeCab_Lattice_create() -> *mut MeCab_Lattice;
}
impl MeCab_Lattice {
    #[inline]
    pub unsafe fn create() -> *mut MeCab_Lattice {
        MeCab_Lattice_create()
    }
}
#[repr(C)]
pub struct MeCab_Model__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Model class"]
#[repr(C)]
#[derive(Debug)]
pub struct MeCab_Model {
    pub vtable_: *const MeCab_Model__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_MeCab_Model() {
    assert_eq!(
        ::std::mem::size_of::<MeCab_Model>(),
        8usize,
        concat!("Size of: ", stringify!(MeCab_Model))
    );
    assert_eq!(
        ::std::mem::align_of::<MeCab_Model>(),
        8usize,
        concat!("Alignment of ", stringify!(MeCab_Model))
    );
}
extern "C" {
    #[doc = " Return a version string"]
    #[doc = " @return version string"]
    #[link_name = "\u{1}_ZN5MeCab5Model7versionEv"]
    pub fn MeCab_Model_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Factory method to create a new Model with a specified main's argc/argv-style parameters."]
    #[doc = " Return NULL if new model cannot be initialized. Use MeCab::getLastError() to obtain the"]
    #[doc = " cause of the errors."]
    #[doc = " @return new Model object"]
    #[doc = " @param argc number of parameters"]
    #[doc = " @param argv parameter list"]
    #[link_name = "\u{1}_ZN5MeCab5Model6createEiPPc"]
    pub fn MeCab_Model_create(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut MeCab_Model;
}
extern "C" {
    #[doc = " Factory method to create a new Model with a string parameter representation, i.e.,"]
    #[doc = " \"-d /user/local/mecab/dic/ipadic -Ochasen\"."]
    #[doc = " Return NULL if new model cannot be initialized. Use MeCab::getLastError() to obtain the"]
    #[doc = " cause of the errors."]
    #[doc = " @return new Model object"]
    #[doc = " @param arg single string representation of the argment."]
    #[link_name = "\u{1}_ZN5MeCab5Model6createEPKc"]
    pub fn MeCab_Model_create1(arg: *const ::std::os::raw::c_char) -> *mut MeCab_Model;
}
impl MeCab_Model {
    #[inline]
    pub unsafe fn version() -> *const ::std::os::raw::c_char {
        MeCab_Model_version()
    }
    #[inline]
    pub unsafe fn create(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut MeCab_Model {
        MeCab_Model_create(argc, argv)
    }
    #[inline]
    pub unsafe fn create1(arg: *const ::std::os::raw::c_char) -> *mut MeCab_Model {
        MeCab_Model_create1(arg)
    }
}
#[repr(C)]
pub struct MeCab_Tagger__bindgen_vtable(::std::os::raw::c_void);
#[doc = " Tagger class"]
#[repr(C)]
#[derive(Debug)]
pub struct MeCab_Tagger {
    pub vtable_: *const MeCab_Tagger__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_MeCab_Tagger() {
    assert_eq!(
        ::std::mem::size_of::<MeCab_Tagger>(),
        8usize,
        concat!("Size of: ", stringify!(MeCab_Tagger))
    );
    assert_eq!(
        ::std::mem::align_of::<MeCab_Tagger>(),
        8usize,
        concat!("Alignment of ", stringify!(MeCab_Tagger))
    );
}
extern "C" {
    #[doc = " Handy static method."]
    #[doc = " Return true if lattice is parsed successfully."]
    #[doc = " This function is equivalent to"]
    #[doc = " {"]
    #[doc = "   Tagger *tagger = model.createModel();"]
    #[doc = "   cosnt bool result = tagger->parse(lattice);"]
    #[doc = "   delete tagger;"]
    #[doc = "   return result;"]
    #[doc = " }"]
    #[doc = " @return boolean"]
    #[link_name = "\u{1}_ZN5MeCab6Tagger5parseERKNS_5ModelEPNS_7LatticeE"]
    pub fn MeCab_Tagger_parse(model: *const MeCab_Model, lattice: *mut MeCab_Lattice) -> bool;
}
extern "C" {
    #[doc = " Factory method to create a new Tagger with a specified main's argc/argv-style parameters."]
    #[doc = " Return NULL if new model cannot be initialized. Use MeCab::getLastError() to obtain the"]
    #[doc = " cause of the errors."]
    #[doc = " @return new Tagger object"]
    #[doc = " @param argc number of parameters"]
    #[doc = " @param argv parameter list"]
    #[link_name = "\u{1}_ZN5MeCab6Tagger6createEiPPc"]
    pub fn MeCab_Tagger_create(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut MeCab_Tagger;
}
extern "C" {
    #[doc = " Factory method to create a new Tagger with a string parameter representation, i.e.,"]
    #[doc = " \"-d /user/local/mecab/dic/ipadic -Ochasen\"."]
    #[doc = " Return NULL if new model cannot be initialized. Use MeCab::getLastError() to obtain the"]
    #[doc = " cause of the errors."]
    #[doc = " @return new Model object"]
    #[doc = " @param arg single string representation of the argment."]
    #[link_name = "\u{1}_ZN5MeCab6Tagger6createEPKc"]
    pub fn MeCab_Tagger_create1(arg: *const ::std::os::raw::c_char) -> *mut MeCab_Tagger;
}
extern "C" {
    #[doc = " Return a version string"]
    #[doc = " @return version string"]
    #[link_name = "\u{1}_ZN5MeCab6Tagger7versionEv"]
    pub fn MeCab_Tagger_version() -> *const ::std::os::raw::c_char;
}
impl MeCab_Tagger {
    #[inline]
    pub unsafe fn parse(model: *const MeCab_Model, lattice: *mut MeCab_Lattice) -> bool {
        MeCab_Tagger_parse(model, lattice)
    }
    #[inline]
    pub unsafe fn create(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut MeCab_Tagger {
        MeCab_Tagger_create(argc, argv)
    }
    #[inline]
    pub unsafe fn create1(arg: *const ::std::os::raw::c_char) -> *mut MeCab_Tagger {
        MeCab_Tagger_create1(arg)
    }
    #[inline]
    pub unsafe fn version() -> *const ::std::os::raw::c_char {
        MeCab_Tagger_version()
    }
}
extern "C" {
    #[doc = " Alias of Lattice::create()"]
    #[link_name = "\u{1}_ZN5MeCab13createLatticeEv"]
    pub fn MeCab_createLattice() -> *mut MeCab_Lattice;
}
extern "C" {
    #[doc = " Alias of Mode::create(argc, argv)"]
    #[link_name = "\u{1}_ZN5MeCab11createModelEiPPc"]
    pub fn MeCab_createModel(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut MeCab_Model;
}
extern "C" {
    #[doc = " Alias of Mode::create(arg)"]
    #[link_name = "\u{1}_ZN5MeCab11createModelEPKc"]
    pub fn MeCab_createModel1(arg: *const ::std::os::raw::c_char) -> *mut MeCab_Model;
}
extern "C" {
    #[doc = " Alias of Tagger::create(argc, argv)"]
    #[link_name = "\u{1}_ZN5MeCab12createTaggerEiPPc"]
    pub fn MeCab_createTagger(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut MeCab_Tagger;
}
extern "C" {
    #[doc = " Alias of Tagger::create(arg)"]
    #[link_name = "\u{1}_ZN5MeCab12createTaggerEPKc"]
    pub fn MeCab_createTagger1(arg: *const ::std::os::raw::c_char) -> *mut MeCab_Tagger;
}
extern "C" {
    #[doc = " delete Lattice object."]
    #[doc = " This method calles \"delete lattice\"."]
    #[doc = " In some environment, e.g., MS-Windows, an object allocated inside a DLL must be deleted in the same DLL too."]
    #[doc = " @param lattice lattice object"]
    #[link_name = "\u{1}_ZN5MeCab13deleteLatticeEPNS_7LatticeE"]
    pub fn MeCab_deleteLattice(lattice: *mut MeCab_Lattice);
}
extern "C" {
    #[doc = " delete Model object."]
    #[doc = " This method calles \"delete model\"."]
    #[doc = " In some environment, e.g., MS-Windows, an object allocated inside a DLL must be deleted in the same DLL too."]
    #[doc = " @param model model object"]
    #[link_name = "\u{1}_ZN5MeCab11deleteModelEPNS_5ModelE"]
    pub fn MeCab_deleteModel(model: *mut MeCab_Model);
}
extern "C" {
    #[doc = " delete Tagger object."]
    #[doc = " This method calles \"delete tagger\"."]
    #[doc = " In some environment, e.g., MS-Windows, an object allocated inside a DLL must be deleted in the same DLL too."]
    #[doc = " @param tagger tagger object"]
    #[link_name = "\u{1}_ZN5MeCab12deleteTaggerEPNS_6TaggerE"]
    pub fn MeCab_deleteTagger(tagger: *mut MeCab_Tagger);
}
extern "C" {
    #[doc = " Return last error string."]
    #[doc = " @return error string"]
    #[link_name = "\u{1}_ZN5MeCab12getLastErrorEv"]
    pub fn MeCab_getLastError() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " An alias of getLastError."]
    #[doc = " It is kept for backward compatibility."]
    #[doc = " @return error string"]
    #[link_name = "\u{1}_ZN5MeCab14getTaggerErrorEv"]
    pub fn MeCab_getTaggerError() -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mecab {
    pub feature: *mut *mut ::std::os::raw::c_char,
    pub size: ::std::os::raw::c_int,
    pub model: *mut ::std::os::raw::c_void,
    pub tagger: *mut ::std::os::raw::c_void,
    pub lattice: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout__Mecab() {
    assert_eq!(
        ::std::mem::size_of::<_Mecab>(),
        40usize,
        concat!("Size of: ", stringify!(_Mecab))
    );
    assert_eq!(
        ::std::mem::align_of::<_Mecab>(),
        8usize,
        concat!("Alignment of ", stringify!(_Mecab))
    );
    fn test_field_feature() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_Mecab>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).feature) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_Mecab),
                "::",
                stringify!(feature)
            )
        );
    }
    test_field_feature();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_Mecab>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_Mecab),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_model() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_Mecab>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).model) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_Mecab),
                "::",
                stringify!(model)
            )
        );
    }
    test_field_model();
    fn test_field_tagger() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_Mecab>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tagger) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_Mecab),
                "::",
                stringify!(tagger)
            )
        );
    }
    test_field_tagger();
    fn test_field_lattice() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_Mecab>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lattice) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_Mecab),
                "::",
                stringify!(lattice)
            )
        );
    }
    test_field_lattice();
}
pub type Mecab = _Mecab;
extern "C" {
    pub fn Mecab_initialize(m: *mut Mecab) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Mecab_load(
        m: *mut Mecab,
        dicdir: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Mecab_analysis(
        m: *mut Mecab,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Mecab_print(m: *mut Mecab) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Mecab_get_size(m: *mut Mecab) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Mecab_get_feature(m: *mut Mecab) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn Mecab_refresh(m: *mut Mecab) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Mecab_clear(m: *mut Mecab) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NJDNode {
    pub string: *mut ::std::os::raw::c_char,
    pub pos: *mut ::std::os::raw::c_char,
    pub pos_group1: *mut ::std::os::raw::c_char,
    pub pos_group2: *mut ::std::os::raw::c_char,
    pub pos_group3: *mut ::std::os::raw::c_char,
    pub ctype: *mut ::std::os::raw::c_char,
    pub cform: *mut ::std::os::raw::c_char,
    pub orig: *mut ::std::os::raw::c_char,
    pub read: *mut ::std::os::raw::c_char,
    pub pron: *mut ::std::os::raw::c_char,
    pub acc: ::std::os::raw::c_int,
    pub mora_size: ::std::os::raw::c_int,
    pub chain_rule: *mut ::std::os::raw::c_char,
    pub chain_flag: ::std::os::raw::c_int,
    pub prev: *mut _NJDNode,
    pub next: *mut _NJDNode,
}
#[test]
fn bindgen_test_layout__NJDNode() {
    assert_eq!(
        ::std::mem::size_of::<_NJDNode>(),
        120usize,
        concat!("Size of: ", stringify!(_NJDNode))
    );
    assert_eq!(
        ::std::mem::align_of::<_NJDNode>(),
        8usize,
        concat!("Alignment of ", stringify!(_NJDNode))
    );
    fn test_field_string() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NJDNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).string) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NJDNode),
                "::",
                stringify!(string)
            )
        );
    }
    test_field_string();
    fn test_field_pos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NJDNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NJDNode),
                "::",
                stringify!(pos)
            )
        );
    }
    test_field_pos();
    fn test_field_pos_group1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NJDNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pos_group1) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_NJDNode),
                "::",
                stringify!(pos_group1)
            )
        );
    }
    test_field_pos_group1();
    fn test_field_pos_group2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NJDNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pos_group2) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_NJDNode),
                "::",
                stringify!(pos_group2)
            )
        );
    }
    test_field_pos_group2();
    fn test_field_pos_group3() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NJDNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pos_group3) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_NJDNode),
                "::",
                stringify!(pos_group3)
            )
        );
    }
    test_field_pos_group3();
    fn test_field_ctype() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NJDNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ctype) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_NJDNode),
                "::",
                stringify!(ctype)
            )
        );
    }
    test_field_ctype();
    fn test_field_cform() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NJDNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cform) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_NJDNode),
                "::",
                stringify!(cform)
            )
        );
    }
    test_field_cform();
    fn test_field_orig() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NJDNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).orig) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_NJDNode),
                "::",
                stringify!(orig)
            )
        );
    }
    test_field_orig();
    fn test_field_read() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NJDNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_NJDNode),
                "::",
                stringify!(read)
            )
        );
    }
    test_field_read();
    fn test_field_pron() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NJDNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pron) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_NJDNode),
                "::",
                stringify!(pron)
            )
        );
    }
    test_field_pron();
    fn test_field_acc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NJDNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).acc) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_NJDNode),
                "::",
                stringify!(acc)
            )
        );
    }
    test_field_acc();
    fn test_field_mora_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NJDNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mora_size) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(_NJDNode),
                "::",
                stringify!(mora_size)
            )
        );
    }
    test_field_mora_size();
    fn test_field_chain_rule() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NJDNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).chain_rule) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_NJDNode),
                "::",
                stringify!(chain_rule)
            )
        );
    }
    test_field_chain_rule();
    fn test_field_chain_flag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NJDNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).chain_flag) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_NJDNode),
                "::",
                stringify!(chain_flag)
            )
        );
    }
    test_field_chain_flag();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NJDNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_NJDNode),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NJDNode>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_NJDNode),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
}
pub type NJDNode = _NJDNode;
extern "C" {
    pub fn NJDNode_initialize(node: *mut NJDNode);
}
extern "C" {
    pub fn NJDNode_set_string(node: *mut NJDNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJDNode_set_pos(node: *mut NJDNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJDNode_set_pos_group1(node: *mut NJDNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJDNode_set_pos_group2(node: *mut NJDNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJDNode_set_pos_group3(node: *mut NJDNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJDNode_set_ctype(node: *mut NJDNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJDNode_set_cform(node: *mut NJDNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJDNode_set_orig(node: *mut NJDNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJDNode_set_read(node: *mut NJDNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJDNode_set_pron(node: *mut NJDNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJDNode_set_acc(node: *mut NJDNode, acc: ::std::os::raw::c_int);
}
extern "C" {
    pub fn NJDNode_set_mora_size(node: *mut NJDNode, size: ::std::os::raw::c_int);
}
extern "C" {
    pub fn NJDNode_set_chain_rule(node: *mut NJDNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJDNode_set_chain_flag(node: *mut NJDNode, flag: ::std::os::raw::c_int);
}
extern "C" {
    pub fn NJDNode_add_string(node: *mut NJDNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJDNode_add_orig(node: *mut NJDNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJDNode_add_read(node: *mut NJDNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJDNode_add_pron(node: *mut NJDNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJDNode_add_acc(node: *mut NJDNode, acc: ::std::os::raw::c_int);
}
extern "C" {
    pub fn NJDNode_add_mora_size(node: *mut NJDNode, size: ::std::os::raw::c_int);
}
extern "C" {
    pub fn NJDNode_get_string(node: *mut NJDNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn NJDNode_get_pos(node: *mut NJDNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn NJDNode_get_pos_group1(node: *mut NJDNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn NJDNode_get_pos_group2(node: *mut NJDNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn NJDNode_get_pos_group3(node: *mut NJDNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn NJDNode_get_ctype(node: *mut NJDNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn NJDNode_get_cform(node: *mut NJDNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn NJDNode_get_orig(node: *mut NJDNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn NJDNode_get_read(node: *mut NJDNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn NJDNode_get_pron(node: *mut NJDNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn NJDNode_get_acc(node: *mut NJDNode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn NJDNode_get_mora_size(node: *mut NJDNode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn NJDNode_get_chain_rule(node: *mut NJDNode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn NJDNode_get_chain_flag(node: *mut NJDNode) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn NJDNode_load(node: *mut NJDNode, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJDNode_insert(
        prev: *mut NJDNode,
        next: *mut NJDNode,
        node: *mut NJDNode,
    ) -> *mut NJDNode;
}
extern "C" {
    pub fn NJDNode_copy(node1: *mut NJDNode, node2: *mut NJDNode);
}
extern "C" {
    pub fn NJDNode_print(node: *mut NJDNode);
}
extern "C" {
    pub fn NJDNode_fprint(node: *mut NJDNode, fp: *mut FILE);
}
extern "C" {
    pub fn NJDNode_sprint(
        node: *mut NJDNode,
        buff: *mut ::std::os::raw::c_char,
        split_code: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn NJDNode_clear(node: *mut NJDNode);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NJD {
    pub head: *mut NJDNode,
    pub tail: *mut NJDNode,
}
#[test]
fn bindgen_test_layout__NJD() {
    assert_eq!(
        ::std::mem::size_of::<_NJD>(),
        16usize,
        concat!("Size of: ", stringify!(_NJD))
    );
    assert_eq!(
        ::std::mem::align_of::<_NJD>(),
        8usize,
        concat!("Alignment of ", stringify!(_NJD))
    );
    fn test_field_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NJD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).head) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_NJD),
                "::",
                stringify!(head)
            )
        );
    }
    test_field_head();
    fn test_field_tail() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_NJD>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tail) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_NJD),
                "::",
                stringify!(tail)
            )
        );
    }
    test_field_tail();
}
pub type NJD = _NJD;
extern "C" {
    pub fn NJD_initialize(njd: *mut NJD);
}
extern "C" {
    pub fn NJD_load(njd: *mut NJD, str_: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn NJD_load_from_fp(njd: *mut NJD, fp: *mut FILE);
}
extern "C" {
    pub fn NJD_get_size(njd: *mut NJD) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn NJD_push_node(njd: *mut NJD, node: *mut NJDNode);
}
extern "C" {
    pub fn NJD_remove_node(njd: *mut NJD, node: *mut NJDNode) -> *mut NJDNode;
}
extern "C" {
    pub fn NJD_remove_silent_node(njd: *mut NJD);
}
extern "C" {
    pub fn NJD_print(njd: *mut NJD);
}
extern "C" {
    pub fn NJD_fprint(njd: *mut NJD, fp: *mut FILE);
}
extern "C" {
    pub fn NJD_sprint(
        njd: *mut NJD,
        buff: *mut ::std::os::raw::c_char,
        split_code: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn NJD_refresh(njd: *mut NJD);
}
extern "C" {
    pub fn NJD_clear(wl: *mut NJD);
}
extern "C" {
    pub fn njd2jpcommon(jpcommon: *mut JPCommon, njd: *mut NJD);
}
extern "C" {
    pub fn njd_set_accent_phrase(njd: *mut NJD);
}
extern "C" {
    pub fn njd_set_accent_type(njd: *mut NJD);
}
extern "C" {
    pub fn njd_set_digit(njd: *mut NJD);
}
extern "C" {
    pub fn njd_set_long_vowel(njd: *mut NJD);
}
extern "C" {
    pub fn njd_set_pronunciation(njd: *mut NJD);
}
extern "C" {
    pub fn njd_set_unvoiced_vowel(njd: *mut NJD);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum text2mecab_result_t {
    TEXT2MECAB_RESULT_SUCCESS = 0,
    TEXT2MECAB_RESULT_INVALID_ARGUMENT = 1,
    TEXT2MECAB_RESULT_RANGE_ERROR = 2,
}
extern "C" {
    pub fn text2mecab(
        output: *mut ::std::os::raw::c_char,
        sizeOfOutput: usize,
        input: *const ::std::os::raw::c_char,
    ) -> text2mecab_result_t;
}
extern "C" {
    pub fn mecab2njd(
        njd: *mut NJD,
        feature: *mut *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
    );
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    fn test_field_gp_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(gp_offset)
            )
        );
    }
    test_field_gp_offset();
    fn test_field_fp_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(fp_offset)
            )
        );
    }
    test_field_fp_offset();
    fn test_field_overflow_arg_area() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(overflow_arg_area)
            )
        );
    }
    test_field_overflow_arg_area();
    fn test_field_reg_save_area() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__va_list_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__va_list_tag),
                "::",
                stringify!(reg_save_area)
            )
        );
    }
    test_field_reg_save_area();
}
